:toc:
:all: {asterisk}{asterisk}
:images: https://github.com/heowc/top-spring-security-architecture-translation-kr/raw/master/images

= Spring Security 이해하기

이 가이드는 Spring Security에 대한 입문서로 이 프레임워크의 디자인과 기본 구조 단위를 간파할 수 있도록 제공해준다. 우리는 오직 애플케이션 보안의 매우 기본들을 다루지만, 그렇게함으로써 Spring Security를 사용하는 개발자들이 겪었던 혼란의 일부를 해결할 수 있다. 이를 위해 filter를 사용하는 웹 애플리케이션에서 보안이 적용되는 방식을 살펴보고 보다 일반적으로 사용하는 method annotation들을 다뤄본다. 이 가이드는 애플리케이션 보안의 동작 원리와 커스텀되어질 수 있는 방법을 이해해야 하거나 애플리케이션의 보안에 대해 생각하는 방법을 배워야할 필요가 있다면 사용해라.

이 가이드는 가장 기본적인 문제들 이상의 것을 해결하기 위한 매뉴얼이나 방법를 제공하지 않지만, 초보자와 전문가 모두에게 유용할 수 있다. Spring Boot는 애플리케이션 보안에 대한 기본 동작 일부를 제공하기 때문에 전체 아키텍처와 어떻게 잘 맞는지 이해하는 것에 유용할 수 있다. 모든 원칙은 Spring Boot를 사용하지 않는 애플리케이션에도 똑같이 적용된다.


== 인증 및 액세스 제어

애플리케이션 보안은 두 가지 또는 그 이상의 독립적인 문제로 귀결된다: 인증(누구니?) 와 권한 부여(무엇을 할 수 있니?). 때때로 사람들은 혼란을 줄 수 있는 "권한 부여" 대신 "액세스 제어"라고 말하지만 "권한 부여"가 다른 영역들에서 과중될 수 있기 때문에 그렇게 생각하면 도움이 될 수 있다. Spring Security는 인증과 인증을 분리하도록 설계된 아키텍쳐를 가지고 있고, 둘에 대한 전력과 확장 요소를 가지고 있다.


=== 인증

인증을 위한 주요 전략 인터페이스는 오직 하나의 메소드만 가진 `AuthenticationManager` 이다:

[source,java]
----
public interface AuthenticationManager {

  Authentication authenticate(Authentication authentication)
    throws AuthenticationException;

}
----

`AuthenticationManager` 는 `auauthenticate()` 메소드에서 세 가지 중 하나를 수행할 수 있다:

1. 입력이 유효한 principal를 나타낼 수 있는 경우는 `Authentication` (일반적으로는 `authenticated=true`)을 반환한다.

2. 입력이 무효인 principal를 나타내고 있는 것 이라고 판단했을 경우는 `AuthenticationException`를 던진다.

3. 결정할 수 없는 경우는 `null`를 반환한다.

`AuthenticationException` 은 runtime exception이다. 보통 애플리케이션의 스타일이나 용도에 따른 일반적인 방식으로 애플리케이션에서 처리된다. 다시 말해서 사용자 코드는 일반적으로 이를 잡아서 처리하지 못 한다. 예를 들어, 웹 UI는 인증이 실패했다는 것을 나타내는 페이지를 렌더링 하고, 백엔드 HTTP 서비스는 컨텍스트에 따라 `WWW-Authenticate` header의 유무와 상관없이 401 응답을 보낼 것 이다.

`AuthenticationManager` 의 가장 일반적으로 사용되는 구현은 `ProviderManager` 는 일련의 `AuthenticationProvider` 인스턴스들에 위임한다. `AuthenticationProvider` 는 `AuthenticationManager` 와 약간 비슷하다. 하지만, `AuthenticationProvider` 는 호출자가 주어진 `Authentication` 타입을 지원 하는지를 질의 할 수 있는 추가 메소드가 있다 :

[source,java]
----
public interface AuthenticationProvider {

	Authentication authenticate(Authentication authentication)
			throws AuthenticationException;

	boolean supports(Class<?> authentication);

}
----

`supports()` 메소드의 `Class<?>` 어규먼트는 실제로 `Class<? extends authentication>` 이다. (`authenticate()` 메소드에 전달 될 항목을 지원하는지 여부를 묻는 메시지만 표시됨) `ProviderManager` 는 일련의 `AuthenticationProvider` 에 위임하여 동일 애플리케이션 안에서 여러 인증 메커니즘을 지원할 수 있다. `ProviderManager` 가 특정 `Authentication` 인스턴스 타입을 인식하지 못하면 `ProviderManager` 는 건너뛴다.

`ProviderManager` 는 선택적 부모를 가지고 있어 모든 프로바이더가 `null` 을 돌려주는 경우에는 참고 한다. 만약 부모를 이용할 수 없는 경우, `null` `Authentication` 결과는 `AuthenticationException` 가 된다.

때때로 애플리케이션이 보호된 리소스(예. `/api/{all}` 패턴과 일치하는 모든 웹 리소스)의 논리적인 그룹들이 있고, 각각의 그룹들은 고유한 `AuthenticationManager` 를 가지고 있을 수 있다. 각각의 그룹은 `ProviderManager` 이며, 부모와 공유한다. 그런 다음 부모는 일종의 "글로벌" 리소스로서, 모든 프로바이더에 대한 대체 역할을 한다.

.`ProviderManager` 를 사용하는 `AuthenticationManager` 계층 구조
image::{images}/authentication.png[ProviderManagers with a common parent,70%]


=== 인증 관리자 커스터마이징

Spring Security는 당신의 애플리케이션에 설정된 공통 인증 관리자 기능을 신속하게 가져올 수 있는 몇 가지 구성 헬퍼를 제공한다. 가장 일반적으로 사용되는 헬퍼는 in-memory, JDBC 또는 LDAP 사용자 세부 정보를 설정하거나 사용자 정의 `UserDetailsService` 를 추가 하는데 유용한 `AuthenticationManagerBuilder` 이다. 다음은 전역 (부모) `AuthenticationManager` 를 구성하는 애플리케이션의 예이다:

[source, java]
----
@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

   ... // web stuff here

  @Autowired
  public initialize(AuthenticationManagerBuilder builder, DataSource dataSource) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser("dave")
      .password("secret").roles("USER");
  }

}
----

이 예제는 웹 애플리케이션과 관련되어 있지만 `AuthenticationManagerBuilder` 의 사용법은 보다 광범위하게 적용될 수 있다 (웹 애플리케이션 보안 구현 방법에 대한 자세한 내용은 아래 참조). `AuthenticationManagerBuilder` 는 `@Bean` 의 메소드에 `@Autowired` 된다는 점에 유의해라. 이것은 전역 (부모) `AuthenticationManager` 를 만드는 부분이다. 대조적으로 우리가 이 방법으로 했을 경우:

[source, java]
----
@Configuration
public class ApplicationSecurity extends WebSecurityConfigurerAdapter {

  @Autowired
  DataSource dataSource;

   ... // web stuff here

  @Override
  public configure(AuthenticationManagerBuilder builder) {
    builder.jdbcAuthentication().dataSource(dataSource).withUser("dave")
      .password("secret").roles("USER");
  }

}
----

(configurer의 메소드의 `@Override` 를 사용하면) `AuthenticationManagerBuilder` 는 오직 "local" `AuthenticationManager` 를 구축하는데 사용된다. Spring Boot에서는 전역 bean을 다른 bean에 `@Autowired` 할 수는 있지만, 명시적으로 직접 노출하지 않는 한 지역 bean으로는 할 수 없다.

Spring Boot는 `AuthenticationManager` 타입의 bean을 제공함으로써 먼저 차지하지 않는 한 (하나의 user만 가진) 기본 전역 `AuthenticationManager` 를 제공한다. 기본값은 사용자 정의 전역 `AuthenticationManager` 를 적극적으로 필요로 하지 않는다면, 걱정할 필요가 없을 정도로 충분히 안전하다. `AuthenticationManager` 를 만드는 설정을 하는 경우는 보호하고 있는 리소스에 대해서 지역적으로 수행할 수 있고 전역의 기본에 대해서는 걱정하지 마라.


=== Authorization or Access Control

Once authentication is successful, we can move on to authorization,
and the core strategy here is `AccessDecisionManager`. There are three
implementations provided by the framework and all three delegate to a
chain of `AccessDecisionVoter`, a bit like the `ProviderManager`
delegates to `AuthenticationProviders`.

An `AccessDecisionVoter` considers an `Authentication` (representing a
principal) and a secure `Object` which as been decorated with
`ConfigAttributes`:

[source, java]
----
boolean supports(ConfigAttribute attribute);

boolean supports(Class<?> clazz);

int vote(Authentication authentication, S object,
        Collection<ConfigAttribute> attributes);
----

The `Object` is completely generic in the signatures of the
`AccessDecisionManager` and `AccessDecisionVoter` - it represents
anything that a user might want to access (a web resource or a method
in a Java class are the two most common cases). The `ConfigAttributes`
are also fairly generic, representing a decoration of the secure
`Object` with some metadata that determine the level of permission
required to access it. `ConfigAttribute` is an interface but it only
has one method which is quite generic and returns a `String`, so these
strings encode in some way the intention of the owner of the resource,
expressing rules about who is allowed to access it. A typical
`ConfigAttribute` is the name of a user role (like `ROLE_ADMIN` or
`ROLE_AUDIT`), and they often have special formats (like the `ROLE_`
prefix) or represent expressions that need to be evaluated.

Most people just use the default `AccessDecisionManager` which is
`AffirmativeBased` (if no voters decline then access is granted). Any
customization tends to happen in the voters, either adding new ones,
or modifying the way that the existing ones work.

It is very common to use `ConfigAttributes` that are Spring Expression
Language (SpEL) expressions, for example `isFullyAuthenticated() &&
hasRole('FOO')`. This is supported by an `AccessDecisionVoter` that
can handle the expressions and create a context for them. To extend
the range of expressions that can be handled requires a custom
implementation of `SecurityExpressionRoot` and sometimes also
`SecurityExpressionHandler`.

== Web Security

Spring Security in the web tier (for UIs and HTTP back ends) is based
on Servlet `Filters`, so it is helpful to look at the role of
`Filters` generally first. The picture below shows the typical
layering of the handlers for a single HTTP request.

image::{images}/filters.png[Filter chain delegating to a Servlet,70%]

The client sends a request to the app, and the container decides which
filters and which servlet apply to it based on the path of the request
URI. At most one servlet can handle a single request, but filters form
a chain, so they are ordered, and in fact a filter can veto the rest
of the chain if it wants to handle the request itself. A filter can
also modify the request and/or the response used in the downstream
filters and servlet. The order of the filter chain is very important,
and Spring Boot manages it through 2 mechanisms: one is that `@Beans`
of type `Filter` can have an `@Order` or implement `Ordered`, and the
other is that they can be part of a `FilterRegistrationBean` that
itself has an order as part of its API. Some off-the-shelf filters
define their own constants to help signal what order they like to be
in relative to each other (e.g. the `SessionRepositoryFilter` from
Spring Session has a `DEFAULT_ORDER` of `Integer.MIN_VALUE + 50`,
which tells us it likes to be early in the chain, but it doesn't rule
out other filters coming before it).

Spring Security is installed as a single `Filter` in the chain, and
its concerete type is `FilterChainProxy`, for reasons that will become
apparent soon. In a Spring Boot app the security filter is a `@Bean`
in the `ApplicationContext`, and it is installed by default so that it
is applied to every request. It is installed at a position defined by
`SecurityProperties.DEFAULT_FILTER_ORDER`, which in turn is anchored
by `FilterRegistrationBean.REQUEST_WRAPPER_FILTER_MAX_ORDER` (the
maximum order that a Spring Boot app expects filters to have if they
wrap the request, modifying its behaviour). There's more to it than
that though: from the point of view of the container Spring Security
is a single filter, but inside it there are additional filters, each
playing a special role. Here's a picture:

.Spring Security is a single physical `Filter` but delegates processing to a chain of internal filters
image::{images}/security-filters.png[Spring Security Filter,70%]

In fact there is even one more layer of indirection in the security
filter: it is usually installed in the container as a
`DelegatingFilterProxy`, which does not have to be a Spring
`@Bean`. The proxy delegates to a `FilterChainProxy` which is always a
`@Bean`, usually with a fixed name of `springSecurityFilterChain`.  It
is the `FilterChainProxy` which contains all the security logic
arranged internally as a chain (or chains) of filters. All the filters
have the same API (they all implement the `Filter` interface from the
Servlet Spec) and they all have the opportunity to veto the rest of
the chain.

There can be multiple filter chains all managed by Spring Security in
the same top level `FilterChainProxy` and all unknown to the
container. The Spring Security filter contains a list of filter
chains, and dispatches a request to the first chain that matches
it. The picture below shows the dispatch happening based on matching
the request path (`/foo/{all}` matches before `/{all}`). This is very
common but not the only way to match a request. The most important
feature of this dispatch process is that only one chain ever handles a
request.

.The Spring Security `FilterChainProxy` dispatches requests to the first chain that matches.
image::{images}/security-filters-dispatch.png[Security Filter Dispatch,70%]

A vanilla Spring Boot application with no custom security
configuration has a several (call it n) filter chains, where usually
n=6. The first (n-1) chains are there just to ignore static resource
patterns, like `/css/{all}` and `/images/{all}`, and the error view
`/error` (the paths can be controlled by the user with
`security.ignored` from the `SecurityProperties` configuration
bean). The last chain matches the catch all path `/{all}` and is more
active, containing logic for authentication, authorization, exception
handling, session handling, header writing, etc. There are a total of
11 filters in this chain by default, but normally it is not necessary
for users to concern themselves with which filters are used and when.

NOTE: The fact that all filters internal to Spring Security are
unknown to the container is important, especially in a Spring Boot
application, where all `@Beans` of type `Filter` are registered
automatically with the container by default. So if you want to add a
custom filter to the security chain, you need to either not make it a
`@Bean` or wrap it in a `FilterRegistrationBean` that explicitly
disables the container registration.

=== Creating and Customizing Filter Chains

The default fallback filter chain in a Spring Boot app (the one with
the `/{all}` request matcher) has a predefined order of
`SecurityProperties.BASIC_AUTH_ORDER`. You can switch it off
completely by setting `security.basic.enabled=false`, or you can use
it as a fallback and just define other rules with a lower order. To do
that just add a `@Bean` of type `WebSecurityConfigurerAdapter` (or
`WebSecurityConfigurer`) and decorate the class with `@Order`. Example:

[source,java]
----
@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
     ...;
  }
}
----

This bean will cause Spring Security to add a new filter chain and
order it before the fallback.

Many applications have completely different access rules for one set
of resources compared to another. For example an application that
hosts a UI and a backing API might support cookie-based authentication
with a redirect to a login page for the UI parts, and token-based
authentication with a 401 response to unauthenticated requests for the
API parts. Each set of resources has its own
`WebSecurityConfigurerAdapter` with a unique order and a its own
request matcher. If the matching rules overlap the earliest ordered
filter chain will win.

=== Request Matching for Dispatch and Authorization

A security filter chain (or equivalently a
`WebSecurityConfigurerAdapter`) has a request matcher that is used for
deciding whether to apply it to an HTTP request. Once the decision is
made to apply a particular filter chain, no others are applied. But
within a filter chain you can have more fine grained control of
authorization by setting additional matchers in the `HttpSecurity`
configurer. Example:

[source,java]
----
@Configuration
@Order(SecurityProperties.BASIC_AUTH_ORDER - 10)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
      .authorizeRequests()
        .antMatchers("/foo/bar").hasRole("BAR")
        .antMatchers("/foo/spam").hasRole("SPAM")
        .anyRequest().isAuthenticated();
  }
}
----

One of the easiest mistakes to make with configuring Spring Security
is to forget that these matchers apply to different processes, one is
a request matcher for the whole filter chain, and the other is only to
choose the access rule to apply.

=== Combining Application Security Rules with Actuator Rules

If you are using the Spring Boot Actuator for management endpoints,
you probably want them to be secure, and by default they will be. In
fact as soon as you add the Actuator to a secure application you get
an additional filter chain that applies only to the actuator
endpoints. It is defined with a request matcher that matches only
actuator endpoints and it has an order of
`ManagementServerProperties.BASIC_AUTH_ORDER` which is 5 fewer than
the default `SecurityProperties` fallback filter, so it is consulted
before the fallback.

If you want your application security rules to apply to the actuator
endpoints you can add a filter chain ordered earlier than the actuator
one and with a request matcher that includes all actuator
endpoints. If you prefer the default security settings for the
actuator endpoints, then the easiest thing is to add your own filter
later than the actuator one, but earlier than the fallback
(e.g. `ManagementServerProperties.BASIC_AUTH_ORDER + 1`). Example:

[source,java]
----
@Configuration
@Order(ManagementServerProperties.BASIC_AUTH_ORDER + 1)
public class ApplicationConfigurerAdapter extends WebSecurityConfigurerAdapter {
  @Override
  protected void configure(HttpSecurity http) throws Exception {
    http.antMatcher("/foo/**")
     ...;
  }
}
----

NOTE: Spring Security in the web tier is currently tied to the Servlet
API, so it is only really applicable when running an app in a servlet
container, either embedded or otherwise. It is not, however, tied to
Spring MVC or the rest of the Spring web stack, so it can be used in
any servlet application, for instance one using JAX-RS.

== Method Security

As well as support for securing web applications, Spring Security
offers support for applying access rules to Java method
executions. For Spring Security this is just a different type of
"protected resource". For users it means the access rules are declared
using the same format of `ConfigAttribute` strings (e.g. roles or
expressions), but in a different place in your code. The first step is
to enable method security, for example in the top level configuration
for our app:

[source,java]
----
@SpringBootApplication
@EnableGlobalMethodSecurity(securedEnabled = true)
public class SampleSecureApplication {
}
----

Then we can decorate the method resources directly, e.g.

[source,java]
----
@Service
public class MyService {

  @Secured("ROLE_USER")
  public String secure() {
    return "Hello Security";
  }

}
----

This sample is a service with a secure method. If Spring creates a
`@Bean` of this type then it will be proxied and callers will have to
go through a security interceptor before the method is actually
executed. If the access is denied the caller will get an
`AccessDeniedException` instead of the actual method result.

There are other annotations that can be used on methods to enforce
security constraints, notably `@PreAuthorize` and `@PostAuthorize`,
which allow you to write expressions containing references to method
parameters and return values respectively.

TIP: It is not uncommon to combine Web security and method
security. The filter chain provides the user experience features, like
authentication and redirect to login pages etc, and the method
security provides protection at a more granular level.

== Working with Threads

Spring Security is fundamentally thread bound because it needs to make
the current authenticated principal available to a wide variety of
downstream consumers. The basic building block is the
`SecurityContext` which may contain an `Authentication` (and when a
user is logged in it will be an `Authentication` that is explicitly
`authenticated`). You can always access and manipulate the
`SecurityContext` via static convenience methods in
`SecurityContextHolder` which in turn simply manipulate a
`TheadLocal`, e.g.

[source,java]
----
SecurityContext context = SecurityContextHolder.getContext();
Authentication authentication = context.getAuthentication();
assert(authentication.isAuthenticated);
----

It is *not* common for user application code to do this, but it can be
useful if you, for instance, need to write a custom authentication
filter (although even then there are base classes in Spring Security
that can be used where you would avoid needing to use the
`SecurityContextHolder`).

If you need access to the currently authenticated user in a web
endpoint, you can use a method parameter in a `@RequestMapping`. E.g.

[source,java]
----
@RequestMapping("/foo")
public String foo(@AuthenticationPrincipal User user) {
  ... // do stuff with user
}
----

This annotation pulls the current `Authentication` out of the
`SecurityContext` and calls the `getPrincipal()` method on it to yield
the method parameter. The type of the `Principal` in an
`Authentication` is dependent on the `AuthenticationManager` used to
validate the authentication, so this can be a useful little trick to get a type safe reference to your user data.

If Spring Security is in use the `Principal` from the
`HttpServletRequest` will be of type `Authentication`, so you can also
use that directly:

[source,java]
----
@RequestMapping("/foo")
public String foo(Principal principal) {
  Authentication authentication = (Authentication) principal;
  User = (User) authentication.getPrincipal();
  ... // do stuff with user
}
----

This can sometimes be useful if you need to write code that works when
Spring Security is not in use (you would need to be more defensive
about loading the `Authentication` class).

=== Processing Secure Methods Asynchronously

Since the `SecurityContext` is thread bound, if you want to do any
background processing that calls secure methods, e.g. with `@Async`,
you need to ensure that the context is propagated. This boils down to
wrapping the `SecurityContext` up with the task (`Runnable`,
`Callable` etc.) that is executed in the background. Spring Security
provides some helpers to make this easier, such as wrappers for
`Runnable` and `Callable`.  To propagate the `SecurityContext` to
`@Async` methods you need to supply an `AsyncConfigurer` and ensure
the `Executor` is of the correct type:

[source,java]
----
@Configuration
public class ApplicationConfiguration extends AsyncConfigurerSupport {

  @Override
  public Executor getAsyncExecutor() {
    return new DelegatingSecurityContextExecutorService(Executors.newFixedThreadPool(5));
  }

}
----
